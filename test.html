<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Live Stats PNG Generator Test</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; background: #eee; }
  #generateBtn { padding: 10px 20px; font-size: 16px; cursor: pointer; margin: 10px 0; }
  #outputImage { border: 1px solid #ccc; max-width: 100%; margin-top: 20px; }
  select { font-size: 16px; padding: 4px 8px; margin-right: 12px; }
</style>
</head>
<body>

<h1>Live Stats PNG Generator Test</h1>

<label for="daySelect">Select day: </label>
<select id="daySelect">
  <option value="today">Today</option>
  <option value="yesterday">Yesterday</option>
</select>

<button id="generateBtn">Generate PNG</button>
<br />
<img id="outputImage" alt="Generated Stats PNG" />

<script type="module">
// === Your original imports ===
// Update this path to your firebaseInit.js location or config
import { db } from '../firebaseInit.js';
import { collection, query, where, getDocs } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore.js";

const statusIcons = {
  Win: '/admin/images/greenWinner.png',
  Lost: '/admin/images/redLost.png',
  Push: '/admin/images/bluePush.png',
  Pending: '/admin/images/grayPending.png'
};

const STATUS_VALUES = ['Win', 'Lost', 'Push', 'Pending'];

function getESTDate(d) {
  const estOffsetMs = 5 * 60 * 60 * 1000;
  return new Date(d.getTime() - estOffsetMs);
}

function estMidnightDate(date) {
  const estDate = getESTDate(date);
  return new Date(estDate.getFullYear(), estDate.getMonth(), estDate.getDate());
}

function getDateRange(day) {
  const now = new Date();
  const todayEst = estMidnightDate(now);
  let start, end;

  if (day === 'today') {
    start = todayEst;
    end = new Date(start);
    end.setDate(start.getDate() + 1);
  } else if (day === 'yesterday') {
    end = todayEst;
    start = new Date(end);
    start.setDate(end.getDate() - 1);
  } else {
    throw new Error('Invalid day for date range');
  }

  return { start, end };
}

async function fetchPicksByDate(day) {
  const { start, end } = getDateRange(day);
  const officialPicksRef = collection(db, 'OfficialPicks');
  const q = query(
    officialPicksRef,
    where('timestamp', '>=', start),
    where('timestamp', '<', end)
  );

  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({
    id: doc.id,
    data: doc.data()
  }));
}

function computeStats(picks) {
  const counts = {
    Win: 0,
    Lost: 0,
    Push: 0,
    Pending: 0,
    Total: picks.length
  };

  picks.forEach(({ data }) => {
    const val = data.gameWinLossDraw;
    if (val === null || val === undefined || val === '' || val === 'null') {
      counts.Pending++;
    } else if (STATUS_VALUES.includes(val)) {
      counts[val]++;
    }
  });

  return counts;
}

// --- Canvas rendering code ---

const watermarkUrl = 'https://capper.ogcapperbets.com/admin/images/blankWatermark.png';

async function loadImage(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = url;
  });
}

async function generateStatsPNG(day, picks) {
  const watermarkImg = await loadImage(watermarkUrl);

  // Canvas sized to watermark image natural size
  const canvas = document.createElement('canvas');
  canvas.width = watermarkImg.naturalWidth;
  canvas.height = watermarkImg.naturalHeight;
  const ctx = canvas.getContext('2d');

  // Draw watermark background
  ctx.drawImage(watermarkImg, 0, 0, canvas.width, canvas.height);

  // Draw header
  ctx.fillStyle = '#222';
  ctx.font = 'bold 36px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('Official Picks Stats Report', canvas.width / 2, 140);

  // Date/time
  ctx.font = '18px Arial';
  ctx.fillStyle = '#555';
  const nowStr = new Date().toLocaleString('en-US', { timeZone: 'America/New_York' });
  ctx.fillText(`Generated: ${nowStr}`, canvas.width / 2, 180);

  // Compute stats
  const counts = computeStats(picks);

  // Draw summary stats below header
  ctx.textAlign = 'center';
  ctx.fillStyle = '#000';
  ctx.font = 'bold 22px Arial';
  const summaryY = 220;
  ctx.fillText(`Total Picks: ${counts.Total}`, canvas.width / 2, summaryY);
  ctx.fillText(`Win: ${counts.Win}`, canvas.width / 2, summaryY + 30);
  ctx.fillText(`Lost: ${counts.Lost}`, canvas.width / 2, summaryY + 60);
  ctx.fillText(`Push: ${counts.Push}`, canvas.width / 2, summaryY + 90);
  ctx.fillText(`Pending: ${counts.Pending}`, canvas.width / 2, summaryY + 120);

  // Draw picks listing starting lower on canvas
  ctx.textAlign = 'left';
  ctx.font = '20px Arial';
  ctx.fillStyle = '#222';

  const leftMargin = 100;
  let y = summaryY + 150;

  for (const pick of picks) {
    const status = pick.data.gameWinLossDraw || 'Pending';
    const iconUrl = statusIcons[status] || statusIcons.Pending;
    const iconImg = await loadImage(iconUrl);

    // Draw status icon circle background
    ctx.beginPath();
    ctx.arc(leftMargin - 40, y - 12, 16, 0, 2 * Math.PI);
    ctx.fillStyle = {
      Win: '#28a745',
      Lost: '#dc3545',
      Push: '#007bff',
      Pending: '#6c757d'
    }[status] || '#000';
    ctx.fill();

    // Draw icon image centered
    ctx.drawImage(iconImg, leftMargin - 56, y - 28, 32, 32);

    // Draw pick text info
    ctx.fillStyle = '#222';
    ctx.fillText(`Team: ${pick.data.teamSelected || 'N/A'}`, leftMargin, y);
    ctx.fillText(`Wager: ${pick.data.wagerType || 'N/A'}`, leftMargin, y + 28);
    ctx.fillText(`Unit: ${pick.data.unit || 'N/A'}`, leftMargin, y + 56);
    ctx.fillText(`Status: ${status}`, leftMargin, y + 84);

    y += 120;

    if (y > canvas.height - 100) {
      // For this test, stop drawing if canvas overflow (or implement pagination)
      break;
    }
  }

  // Return dataURL for display/download
  return canvas.toDataURL('image/png');
}

// === UI handlers ===

const generateBtn = document.getElementById('generateBtn');
const daySelect = document.getElementById('daySelect');
const outputImage = document.getElementById('outputImage');

generateBtn.addEventListener('click', async () => {
  generateBtn.disabled = true;
  generateBtn.textContent = 'Generating...';

  try {
    const day = daySelect.value;
    const picks = await fetchPicksByDate(day);

    const pngDataUrl = await generateStatsPNG(day, picks);
    outputImage.src = pngDataUrl;
  } catch (err) {
    alert('Error generating PNG: ' + err.message);
    console.error(err);
  } finally {
    generateBtn.disabled = false;
    generateBtn.textContent = 'Generate PNG';
  }
});
</script>

</body>
</html>
